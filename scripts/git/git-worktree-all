#!/usr/bin/env bash

# FZF Wrapper over git to interactively work with git worktrees
# Automate your git worktrees create & switch lifecycle

# Dependencies:
# 1. FZF
# 2. Bash>=4
# 3. Basic Utils: AWK, dirname, basename, grep

# READ BEFORE USE
#
# This script assumes the following git worktree flow
#
# SOME_DIRECTORY
# â”‚
# â”œâ”€â”€â”€â”€beepbop (main git repository or main worktree)
# â”‚    â”‚
# â”‚    â”œâ”€â”€â”€â”€.git (dir)
# â”‚    â”‚
# â”‚    â””â”€â”€â”€â”€README.md
# â”‚
# â””â”€â”€â”€â”€beepbop-worktrees (all linked worktrees)
#      â”‚
#      â”œâ”€â”€â”€â”€a1 (linked worktree)
#      â”‚    â”‚
#      â”‚    â”œâ”€â”€â”€â”€.git (file)
#      â”‚    â”‚
#      â”‚    â””â”€â”€â”€â”€README.md
#      â””â”€â”€â”€â”€a2 (linked worktree)
#           â”‚
#           â”œâ”€â”€â”€â”€.git (file)
#           â”‚
#           â””â”€â”€â”€â”€README.md

# Installation & Usage:
#
# $ curl -s https://raw.githubusercontent.com/Bhupesh-V/.Varshney/master/scripts/git/git-worktree-all -o giw
#
# $ source giw
# 
# TODO: set $GIT_WORK_TREE env variable
# TODO: set config for core.worktree
# TODO: highlight the main worktree branch?

RESET=$(tput sgr0)
BOLD=$(tput bold)

create_worktree() {
    # avoid nesting of worktrees by switching to main worktree ðŸ˜…
    # TODO: make this function generic to handle both commit/branch based creation
    switch_to_main_tree

    common_dir=$(dirname "$(pwd)")
    git_main_dir=$(basename "$(pwd)")
    new_worktree="$common_dir/$git_main_dir-worktrees/$1"

    all_branches=$(git for-each-ref --format='%(refname:short)' refs/heads)

    if grep -w "$1" <<< $all_branches 1> /dev/null; then
        # worktree exists with branch $1
        git worktree add "$new_worktree" "$1"
    else
        # create a branch if it doesn't exist
        git worktree add "$new_worktree"
    fi

    printf "%s\n" "Switching to worktree, $BOLD$1${RESET}"
    switch_worktree "$1"
}

switch_worktree() {
    # switch current worktree in the terminal
    worktree=$(git worktree list | grep -m 1 -w "$1" | awk '{print $1}')
    echo $worktree

    cd "$worktree" || printf "%s\n" "Can't find the linked worktree" && return
}

switch_to_main_tree() {
    printf "%s" "Switching to main worktree: " 

    if file .git | grep -w "ASCII text" 1> /dev/null; then
        linked_tree_path=$(cat .git | awk '{print $2}')
        # gitdir: SOME_PATH/.git/worktrees/PWD
        current_linked_tree=$(basename "$(pwd)")
        main_worktree_path=${linked_tree_path%.git/worktrees/$current_linked_tree}
        printf "%s\n" "$BOLD$main_worktree_path$RESET"

        cd "$main_worktree_path" || return

        # verify if we are in main worktree
        if file .git | grep -w ".git: directory" 1> /dev/null; then
            return
        else
            printf "%s\n" "Failed to switch to main worktree"
            exit 1
        fi
    fi
}

init_worktree_menu() {
    # list available branches that have a worktree assoicated with them
    # in any case the default tree with "main" branch is printed

    worktree=$(git for-each-ref --color=always --format='%(if)%(worktreepath)%(then)%(color:bold)%(refname:short)%(color:bold 208) %(align:63,middle)%(worktreepath)%(end)%(color:reset) [Commit:%(color: bold 154)%(objectname:short)%(color:reset)]%(end)' | column -t | fzf \
        --prompt="Choose a Worktree or Create One: " \
        --height 40% --reverse --ansi\
        --header="If a worktree doesn't exist, git will create it for you. Just type in what you want" \
        --bind=enter:replace-query+print-query | awk '{print $1}'
    )

    [[ -z $worktree ]] && return

    # find existing worktrees once again
    available_worktrees=$(git worktree list | awk '{print $3}' | tr -d "[]")

    if grep -w "$worktree" <<< $available_worktrees 1> /dev/null; then
        switch_worktree "$worktree"
    else
        printf "%s\n" "Worktree named ${BOLD}$worktree${RESET} doesn't exist. Creating one..."
        create_worktree $worktree
    fi
}

init_worktree_menu
